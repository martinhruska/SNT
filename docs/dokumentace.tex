\documentclass[a4paper, 12pt]{article}
\usepackage[left=1.5cm, text={18cm, 25cm}, top=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{url}
\usepackage{comment}
\usepackage[longend,ruled,vlined,commentsnumbered,linesnumbered,czech]{algorithm2e}
\newcommand{\myuv}[1]{\quotedblbase #1\textquotedblleft}
\newcommand{\rcps}[0]{Resource Constraint Project Scheduling}

\title{\rcps}
\author{Martin Hruška\\xhrusk16@stud.fit.vutbr.cz}

\date{}
\begin{document}

\maketitle

\section{Úvod}
\label{sec:intro}
% speek about np hardness of problem

\section{Analýza \rcps}
\label{sec:analysis}
V~této sekci bude napřed formálně definován \rcps\ problém a optimalizační problém související s~jeho řešení.
Dále bude popsána knihovna PSPLIB a její formát popisu instancí RCPS problému.
Následně budou zkoumány možnosti a způsoby využití SAT solving při řešení RCPS problému.

\subsection{Formální definice RCPS}
\rcps je definován šesticí $(V, p, E, R, B, b)$ \cite{artigues:2007}, kde
\begin{enumerate}
    \item $V=\{A_0, \ldots, A_{n+1}\}$ je množina aktivit, které mají být vykonány.
    Dle konvence je $A_0$ aktivita reprezentující začátek rozvrhu a $A_{n+1}$ aktivita reprezentující konec rozvrhu.
    \item $p: V~\rightarrow \mathbb{N}$ je funkce udávající dobu trvání aktivit.
    \item $E \subseteq V\times V$ je precedenční relace.
    Pokud $(A_i, A_j) \in E$, tak aktivita $A_i$ musí být provedena před aktivitou $A_j$.
    \item $R=\{R_1,\ldots,R_q\}$ je množina zdrojů.
    \item $B: R \rightarrow \mathbb{N}$ je funkce udávající kapacitu zdrojů.
    \item $b: V~\times R \rightarrow \mathbb{N}$ je funkce udavájící množství určitého zdroje, které vyžaduje daná aktivita pro
    svoje provádění.
\end{enumerate}

Řešením tohoto problému je vektor $<S_0,\ldots,S_{n+1}>$, kde $S_i$ je doba začátku aktivity $A_i$.
Toto řešení můžeme nazývat rozvrhem.
Řešení musí splňovat omezení daná precedenční relací a dostupností zdrojů, což lze formálně zapsat následovně:
\begin{equation}
 \forall (A_i,A_j) \in E: S_j - S_i \geq p(A_i)
\end{equation}
\begin{equation}
 \forall R_k \in R\ \forall t \geq 0: \sum_{A_i \in A_t} b(A_i, R_k) \leq B(k)
\end{equation}
kde $A_t=\{A_i \in A\,|\, S_i \leq t \leq S_i+p(A_i)\}$.

Kritériem optimálnosti u~\rcps je tzv. \emph{makespan}, což je doba začátku provádění aktivity $A_{n+1}$.
Optimalizačním problémem tedy je nalézení řešení \rcps\ úlohy s~minimální makespan.

V~dalším textu jsou uvažovány \emph{single-mode} \rcps\ úlohy.
Single-mode znamená, že aktivity dané úlohy mají pouze jeden mód činnosti,
narozdíl od tzv. \emph{multi-mode} úloh jejichž aktivity mají více módu činnosti
a každý mód má odlišné požadavky na spotřebu zdrojů.

TODO: earliest job and latest start job

% solving methods of rcps
\subsection{PSPLIB}
% what is it and how should I use it
%Dokumentovaný nástroj očekává jako vstup instanci RCSP problému zadanou ve formátu používaném knihovnou \emph{PSPLIB}, jež
%ude v~této sekci stejně jako formát vstupu stručně popsána.
PSPLIB je knihovna združíjící sady instancí \rcps\ problému v~jeho různých variantách a jejich optimální a heuristická řešení \cite{psplib}.
Knihovna používá ke generování instancí problému vlastní nástroj \emph{ProGen}.
Ve shodě se zadáním projektu byly použita data knihovny PSPLIB jako vstupy dokumentováného nástroje.
Použití knihovny je vhodné také díky možnosti porovnávat výstupy vytvořeného programu s~optimálními řešeními, které
knihovna pro mnoho instancí problému obsahuje.
Příklad vstupních dat lze najít v~adresáří \emph{input}.
TODO DECRIBE STRUCTURE OR DETELE THIS

\subsection{SAT Solvinig}
Metody a nástroje SAT solvingu se zabývají řešením SAT problému (který je NP-úplný),
který odpovídá na otázku, zdali je daná formule výrokové logiky splnitelná.
V~našem případě uvažujeme formuli výrokové logiky v~\emph{konjunktnivní} normální formě (CNF).
formule je definovaná přes množinu proměnných, které nabývají hodnoty z~množiny $\{true, false\}$
a je složena z~následujících prvků:
 \begin{itemize}
 	\item \emph{Literálu}, což jsou samotné proměnné nebo jejich negace
 	\item \emph{Klausulí}, což jsou disjunkce ($\vee$) literálů
	\item Samotná výroková formule v~CNF je pak konjunkcí ($\wedge$) klausulí.
 \end{itemize}.

Ohodnocení formule je konkrétní zobrazení jejich proměnných na hodnoty $\{true, false\}$.
Formule je \emph{splnitélná}, pokud existuje ohodnocení, při kterém je celá formule vyhodnocena
jako $true$.
Takové ohodnocení se potom nazývá modelem formule v~CNF.

Programy řešící SAT problém se nazývají \emph{SAT Solvery}.
V~poslední době proběhl v~oblastni SAT solverů výrazný pokrok a mnohé z~nich jsou již
schopny  řešit SAT problémy obsahující velké formule.
Porovnání možností a výkonu SAT solverů lze najít na \cite{www:sat}.

Základním algoritmem použivaným v~SAT Solvingu (a dnešních SAT Solverech) je
\emph{Davis–Putnam\-Logemann–Loveland (DPLL) algoritmus} \cite{dpll:1960, dpll:1962}.
Algoritmus lze najít v~\ref{alg:dpll} a bude následovat jeho krátký popis.

Funkce \emph{propagate} ohodnotí proměnné na základé aktuálního částečného ohodnocení tak, že
provedená nová ohodnocení jsou důsledkem aktuálního stavu.
Pokud při tomtu ohodnocení nevznikne konflikt, t.j. jedna klausule při učitém ohodnocení některé z~proměnných nabyde hodnoty $true$,
zatímco jiná (konfliktní) klausule se při takovémto ohodnocení stane $false$, tak pokud jsou již ohodnoceny všechny proměnné, je vrácena
hodnota $true$.
Pokud konflikt nenastane, ale nejsou ohodnoceny všechny proměnné tak, je zvýšena úroveň zanoření při rozhodování (proměnná decision\_level)
a je zavolána funkce \emph{decide}, která rozhodne, která další proměnná bude ohodnocena a na které se tedy bude další výpočet větvit.

Pokud funkce propagate vrátí konfliktní klausuli, tak je zavolána funkce \emph{analyze}, která určí ke které úrovni zanoření při ohodnocování
proměnných se bude navracet.
Všechna ohodnocení provedena hloubějí než v~této úrovni jsou pak zrušena.
V~moderních SAT Solverech funkce analyze také dokáže vytvořit \emph{naučenou} klausuli, která je důsledkem aktuální databáse klausulí a která
má popisovat příčinu posledního konfliktu konfliktu.

\begin{algorithm}
\label{alg:dpll}
    \KwIn{CNF formule}
    \KwOut{$true$ pokud je formule splnitelná, jinak $false$}
    decision\_level = 0\;
    \While{$true$}
    {
        propagate()\;
        \eIf{Není konflikt}
        {
            \eIf{Všechny proměnné přiřazeny}
            {
                \Return $true$\;
            }
            {
                ++decesion\_level\;
                decide()\;
            }
        }
        {
            analyze()\;
            \eIf{nalezen konflikt na nejvyšší úrovni}
            {
                \Return $false$\;
            }
            {
                backtrack()\;
            }
        }
    }
\caption{DPLL Algoritmus}
\end{algorithm}

V~této práci byly použity SAT Solvery \emph{MiniSAT} \cite{www:minisat} a \emph{Glucose} \cite{www:glucose}, která
používají další optimalizace k~zlepšení efektivity výpočtu.
MiniSAT byl vybrán na základě článku \cite{horbach:10}, kde byl úspěšně použit právě pro řešení RCPS problému.
Glucose je solver založený na MiniSATu, ale implementující některé další optimalizace, a proto s~ní budou provedeny
experimenty, které si kladou za cíl zjistit, zdali přináší zlepšení pro výkonu při řešení RCPS problému.
% how is it used in my model
% used sat solvers

\section{Konceptuální model}
\label{sec:concept}
RCPS problém lze řešit jeho redukcí na SAT problém a následním řešením pomocí SAT solveru.
V~této kapitole bude právě tato redukce popsána a to dle přístupu z~\cite{horbach:10}.

SAT formule budou definovány nad následujícími proměnnými:
\begin{itemize}
    \item Startovací proměnné $s_{it}$, kde $i\in V$ a $t\in{es_i,\ldots,ls_i}$, pro které platí: \newline 
    $s_{it}=
        \left\{
        \begin{array}{ll}
             true & \mbox{pokud} \emph{ aktivita }j \emph{ začíná v~čase }t \\
             false & \mbox{jinak}\\
        \end{array}
        \right.
        $
    \item Procesní proměnné $u_{it}$, kde $i \in V$ a $t \in {es_i,\ldots, lf_i}$, pro které platí: \newline
    $u_{it}=
        \left\{
        \begin{array}{ll}
             true & \mbox{pokud} \emph{ aktivita }j \emph{ je ve zpracování  v~čase }t \\
             false & \mbox{jinak}\\
        \end{array}
        \right.
        $
\end{itemize}

Nyní přistupme k~samotné redukci RCPS problému do CNF formulí.
Správná kombinace startovacích a procesních proměnných je zaručena pomocí tzv. \emph{klausulí konzistence}:
\begin{equation}
\label{eq:1}
   \neg s_{it} \vee u_{il},\emph{ kde } i\in\{es_i,\ldots,ls_i\}, l\in\{t,\ldots,t+d_i-1\}  
\end{equation}

Dodržení omezení daných precedenční relací zajišťují tzv. \emph{precedenční klausule}:
\begin{equation}
\label{eq:2}
   \neg s_{it} \bigvee_{l\in\{es_j,\ldots,t-d_j\}} s_{jl},\emph{ kde } (j,i) \in E, t \in\{es_i,\ldots,ls_i\}   
\end{equation}
Oproti přísputu z~\cite{horbach:10} je zde použito $l\in\{es_j,\ldots,t-d_j\}$ namísto $l\in\{es_j,\ldots,es_i-d_j\}$ tak,
aby klausule skutečně vyjadřovala, že začne-li aktivita $i$ v~čase $t$, tak aktivita, která ji má dle precedenční
relace předcházet, začala dříve alespoň o~svého trvání.

Dalším typem klasulí jsou \emph{klausule startovací}, které zaručují, že každá aktivita někdy začne:
\begin{equation}
\label{eq:3}
   \bigvee_{t\in\{es_i,\ldots,ls_{i}\}} s_{it},\emph{ kde } i \in
V~\end{equation}

Dosud uvedené klausule nezaručují, že nebude v~jeden okamžik naplánováno více aktivit, které ovšem můžou mít rozdílné
větší nároky na některý zdroj než je jeho dostupné množství.
Takovotou množinu aktivit $C$, pro kterou u~některého zdroje $k$ platí $\sum_{i\in C} r_{ik} > R_k$, nazveme \emph{pokrytím}.
Minimální pokrytí je takové, že bez některé aktivity $i\in C$, přestává být množina $C$ prokrytím.
Nepřečerpání některého ze zdrojů lze zajistit porstřednictvím \emph{klausulí pokrytí}:
\begin{equation}
\label{eq:4}
   \bigvee_{i\in C} \neg u_{it},\emph{ kde } t\in{0,\ldots,T-1}, C \emph{ je minimální pokrytí}   
\end{equation}

Každá množina klausulí z~\ref{eq:1},\ref{eq:2},\ref{eq:3} nabývá polynomiální velikosti a je tedy řešitelná pomocí moderních SAT solverů,
a proto je možné je vygenerovat na základě instance RCPS problému před spuštěním SAT solveru.
Počet klausulí \ref{eq:4} ovšem roste exponencíálně, a tudíž by jejich kompletní vygenerování bylo možné jen pro instance
s~malým počtem aktivit,
Proto jsou tyto klasule v~dokumentované implementaci přídávány do databáse SAT solveru dynamicky.
Bližší informace stran implementace samotné jsou v~sekci \ref{sec:arch}.

Aby bylo možné provádět samotnou optimalizaci, je třeba přidat klausule omezující maximální makespan.
Nazvěme tyto klausule \emph{časovými}:
\begin{equation}
\label{eq:5}
   \bigvee_{i\in C} \neg s_{n+1,t},\emph{ kde } t\in{l+1,\ldots,ls_{n+1}}, \emph{ l je maximální makespan}   
\end{equation}

Stejně jako v~\cite{horbach:10} byly přidány následující klausule, které přináší zrychlení výpočtu SAT solveru:
\begin{equation}
\label{eq:6}
   \neg u_{it} \vee u_{i,t+1} \vee u_{i,t-d_i+1},\emph{ kde } i\in V, s\in\{ef_i,\ldots,lf_i-1\}  
\end{equation}
Klausule udávají, že doba $t$ je doba konce aktivity $i$ a SAT solver může odvodit, že aktivita $i$ začíná v~době
$t-d_i+1$.

Tím je redukce RCPS problému na SAT problém kompletní včetně zakódování optimalizačního problému a přídání
klausulí zrychlujících výpočet SAT Solveru.

\section{Architektura}
\label{sec:arch}
V této sekci bude popsána architektura implementovaného programu, implementační optimalizace a budou zmíněny použité SAT Solvery.

Logický návrh architektury programu je na obrázku \ref{fig:arch}.
Program nejprve načte vstup, kterým je soubor z knihovny PSPLIB, poté ho
převede do interní reprezentace (na Obrázku jako \emph{Instance RCPS problému}).
V této interní reprezentaci se instance RCPS problému předá optimilazátoru,
který pomocí příslušných modulů vypočte kritckou cestu a s ní související informace a doplní je do reprezentace RCPS problému.
Následně je vytvořena interní reprezentace SAT problému (SAT formule v CNF), která je následně
převedena do reprezentace příslušného SAT Solveru, který je v nazávěr spuštěn.
Toto optimalizátor postupně provádí pro jednotlivé makespan, dokuď není nalezen ten nejnížší možný.
\begin{figure}
\begin{center}
    \input{arch.tikz}
    \caption{Koncptuální návrh programu}
    \label{fig:arch}
\end{center}
\end{figure}

Následuje seznam tříd implementující jednotlivé bloky z logického návrhu programu:
\begin{itemize}
 \item Parser
    \begin{itemize}
        \item Třída \emph{RCPSParser} obsahuje metody pro načtení souboru se vstupem z PSPLIB a převede ho do interní
        reprezentace RCPS problému (třída \emph{RCPSInstance}).
    \end{itemize}
 \item Instance RCPS problému
    \begin{itemize}
        \item Třída \emph{RCPSInstance} v sobě uchováva informace uvedené v definici RCPS problému v sekci \ref{sec:analysis}.
        Uchovává také informace o nejdřívějších a nejpozdějších možných časech začátků a konců jednotlivých aktivit.
    \end{itemize}
 \item Výpočet kritické cesty
    \begin{itemize}
        \item Třída \emph{RCPSGraph} reprezentuje graf, do které ho je převeden RCPS problém, aby mohla být spočítáná kritická cesta a s ní
        související informace jako možné časy začátků a konců aktivit.
        Obsahuje také metody pro výpočet této kritické cesty pomocí Floyd-Warshallova algoritmu.
    \end{itemize}
 \item Interní SAT model
    \begin{itemize}
        \item Třída \emph{RCPSSATModel} reprezentuje interně SAT problém, na který byl redukován RCPS problém.
        Obsahuje také metody pro tuto redukci.
    \end{itemize}
 \item Převod do reprezentace SAT solveru
    \begin{itemize}
        \item Třída \emph{RCPSModel2Glucose} obsahuje metody převádějící interní SAT model v třídě \emph{RCPSSATModel}
        do interní reprezentace SAT solveru \emph{Glucose}.
        \item Třída \emph{RCPSModel2Minisat} obsahuje metody převádějící interní SAT model v třídě \emph{RCPSSATModel}
        do interní reprezentace SAT solveru \emph{MiniSAT}.
    \end{itemize}
 \item Byly použity následující dva SAT solvery:
    \begin{itemize}
        \item \emph{MiniSAT} \cite{www:minisat} je SAT solver použíty v \cite{horbach:10}.
        Dříve patřil mezi nejlepší SAT solvery (oceněný v soutěži \cite{www:sat}), dnes již neimplemetuje
        všechny aktuální heuristiky a optimalizace používaný v SAT Solvingu.
        \item \emph{Glucose} \cite{www:glucose} je nádstavnou nad MiniSAT, která implementuje
        pokročilejší optimalizace a je v posledních letech oceňována v soutěži SAT Competition \cite{www:sat}.
        Zachovává rozhraní MiniSAT, tudíž ji bylo možné použít bez nutnosti výraznějších změn postupů použitých při
        modifikaci MiniSAT.
    \end{itemize}
 \item Optimalizátor
    \begin{itemize}
        \item Třída \emph{RCPSOptimizer} realizuje vlastní výpočet a optimalizaci pomocí ostatních modulů.
    \end{itemize}
\end{itemize}

\subsection{Modifikace SAT solveru}
Jak bylo řečeno v sekci \ref{sec:concept}, množství klausulí pokrytí \ref{eq:4} dosahuje exponenciální složitosti,
proto není možné tyto klausule vygenerovat před spuštěním samotného SAT solveru.
Je nutné je generovat dle potřeby během výpočtu, což lze udělat tak \cite{horbach:10}, že je spuštěn SAT solver bez
těchto klausulí a na základě vypočteného ohodnocení proměnných je ověřováno, že v žádném čase
nedošlo k přečerpání žádného zdroje.
Pokud by k tomuto došlo, je přidána příslušná klausule pokrytí, která tomuto zabrání a SAT solver je spuštěn
znovu.
Nevýhoda tohoto přístupu je taková, že SAT solver vždy ztrácí celý kontext výpočtu a musí začínat od začátku, a proto
je tento přístup vhodný jen u malých problému, a tedy nebyl v této práci implementován.

Implementován byl přístup, který modifikuje fukci \emph{propagate} v SAT solveru.
Vždy když je pravdivě ohodnocen nějaký literál obsahující procesní proměnnou $u_{it}$, tak je zkontrolováno,
zdali tímto ohodnocením není v čase $t$ překročeno množství některého ze zdrojů použitých aktivitou $i$.
Pokud ano, je vygenerována příslušná klausle pokrytí, která je přidána do databáse klausulí a vrácena jako konflitkní klausule.
Pokud k takovému porušení nedocházi, jsou vygenerovány klausule pokrytí zabraňující tomu, aby byla 
(dosud neohodnocená) procesní proměnná $u_{jt}$ ohodnocena jako $true$,
pokud by činnost aktivity $j$ v čase $t$ vedla k přečerpání některého ze zdrojů.

Přidání nové klausule za běhu nebylo možné provést přes funkci \emph{addClause} z rozhraní SAT solverů, ale použitím
interní funkce \emph{attachClause} a přidáním nové klausule na zásobník klauslí v proměnné \emph{clauses}.

Další provednou optimalizací je upřednostnění výběru procesních proměnných ve funkci \emph{decide} před výběrem
startovacích proměnných.
Tato optimalizace je také navržena v \cite{horbach:10} a empirickými experimenty s programem RCPSSolver
byl ověřeno, že skutečně zrychluje výpočet.

\subsection{Hledání optimálního řešení}
Původně bylo hledání optimálního řešení implementováno tak, že se před
zahájením samotné optimalizace vypočetla kritická cesta a s ní související informace.
Poté byl zvolen makespan dle horního odhadu uvedeného v popisu instance z PSPLIB
a ten byl postupně snižován dokud nebylo dosaženo spodní hranice, která
byla dána kritickou cestou.
Poslední makespan, u kterého bylo možné najít řešení RCPS problému byl pak prohlášen
za optimální řešení.
Tento přístup se ovšem ukázal jako velmi neefektivní, a proto byl
implementován jiný, kde se prohledává od spodní hranice dané kritickou cestou,
makespan se zvyšuje o jedna a jako horní hranice je brána hodnota o jedna
vyšší než aktuální makespan.
Pro tuto horní hranici jsou spočteny nejdřívější a nejpozdější možné začátky
jednotlivých aktivit a teprve poté je RCPS problém zakódován do SAT problému.
Tento postup se ukázal jako efektivnější nejen v hledání optimálního řešení, ale i v
rozhodování jedné instance SAT problému, protože obsahují méně proměnných. 

\subsection{Implementační problémy}
SAT solvery při řešení větších instancí končily chybou \texttt{segmentation fault}.
Příčinu této chyby se nepodařilo zjistit a není zřejmé, zdali se jedná o
chybu zanešenou implementací dynamického přidávání klausulí a nebo o chybu
způsobenou velikostí řešeného problému.
Proto v případech, kdy by mělo k chybě \texttt{segmentation fault} dojít,
je daná instance prohlášena za nesplnitelnou a je zvětšen makespan.
Touto cestou nelze najít opravdu optimální řešení, protože přávě kolem
hodnoty optimálního makespan dochází k nárustu složitosti výpočtu a tedy
i zmíněné chybě, ale lze dostat alespoň suboptimální řešení udavající
nejnižší makespan, pro který jde úloha vyřešit.

\section{Experimenty}
% this is clear

\section{Závěr}
% make this beatiful!

\newpage
\appendix
\section{Instalace}
\label{app:install}
K~projektu je přiložen soubor \emph{Makefile}, tudíž lze zdrojové kódy zkompilovat pomocí příkazu \texttt{make}.
Pro úspěšnou kompilaci je nutné mít nainstalovaný překladač GCC verze 4.8.
Před spuštění je třeba dokončit konfiguraci prostředí skriptem \texttt{configure.sh},
který přidá do systemových proměnných cestu ke knihovnám MiniSAT.
Výstupem kompilace je spustitelný binární soubor \texttt{rcps\_solver} v adresáři \texttt{bin}.
\section{Uživatelský manuál}
\label{app:help}
RCPSSolver lze spouštět z příkazového řádku následujícím způsobem:
\\
\\
  rcps\_solver soubor [solver] [timeout]
  \begin{itemize}
    \item \texttt{soubor} $ldost$ Cesta k~vstupnímu souboru s~instancí problému z PSPLIB
    \end{itemize}
    \item \texttt{solver} $ldost$ Volba SAT solveru.  
    \begin{itemize}
        \item m $\ldots$ MiniSAT (default).
        \item g $\ldots$ Glucose.
    \end{itemize}
    \item \texttt{timeout} $\ldots$ Doba pro řešení optimalizačního problému.
    Neovlivní činnost SAT solveru, takže bude vždy před ukončením programu dořešena poslední SAT úloha.
    \item Pokud jsou oba použity nepovinné parametry \texttt{solver} i \texttt{timeout}, je nutné dodržet jejich pořadí.

\section{Výstup}
\label{app:output}
RCPSSolver průběžně informuje o svojí činnosti na standardní chybový výstup.
Na standardní výstup pak vypisuje následující informace:
\begin{itemize}
    \item \texttt{Makespan: $X$ [$Y$] $U$ $V$} $\ldots$ $X$ je aktuální makespan, $Y$ udává, zdali je úloha řešitelná v daném makespan,
    $U$ je doba řešení SAT problému a $V$ celková doba řešení RCPS problému pro daný makespan, oba údaje jsou v sekundách.
    \item \texttt{Done X} $\ldots$ X je celková doba výpočtu optimalizace RCPS problému v sekundách.
    \item \texttt{Optimal: X} $\ldots$ X je optimální řešení RCPS problému nalezené RCPSolverem.
\end{itemize}
Další výstupy pak mohou být informace, které vypisuje SAT solver.

\newpage
\bibliography{literatura}
\bibliographystyle{czechiso}
\end{document}
