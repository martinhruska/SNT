\documentclass[a4paper, 12pt]{article}
\usepackage[left=1.5cm, text={18cm, 25cm}, top=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{url}
\usepackage{comment}
\usepackage[longend,ruled,vlined,commentsnumbered,linesnumbered,czech]{algorithm2e}
\newcommand{\myuv}[1]{\quotedblbase #1\textquotedblleft}
\newcommand{\rcps}[0]{Resource Constraint Project Scheduling}

\title{\rcps}
\author{Martin Hruška\\xhrusk16@stud.fit.vutbr.cz}

\date{}
\begin{document}

\maketitle

\section{Úvod}
\label{sec:intro}
\rcps\ (RCPS) problém odpovídá na otázku, zdali pro danou množinu aktivit, mezi kterými je definována
relace precedence, z~nich každá má určitou dobu trvání, určité požadavky na zdroje, jejichž množství je omezené,
existuje výrobní rozvrh, v~němž mohou být aktivity provedeny bez konfliktů
Optimalizace RCPS pak spočívá v~nalezení rozvrhu s~nejkratší dobou trvání.

Jelikož je RCPS problém NP-úplný \cite{artigues:2007}, tak se k~jeho řešení používají metody jako
lineární programování, či genetické nebo optimalizační (Ant Colony Optimization) algoritmy.
Tato práce se zabývá implementací optimalizátoru RCPS problému, nazvaného RCPSSolver,
další metodou a tou je redukce na SAT problém.
Nástoje nazývané SAT solvery sloužící k~řešení instancí SAT problému učinily v~posledních letech
svého vývoje výrazný pokrok a dokáží řešit i obtížné instance problému \cite{www:minisat,www:glucose}.
Dále je možné při redukci RCPS problému na SAT určit zdroj exponenciální složitosti a ten
redukovat vhodnou implementací, při níž se předchází generování exponenciálního množství klausulí pro SAT problém.
Výhodou tohoto řešení je také, že se nejdná pouze o~numerickou aproximaci, ale je schopné podat přesné
výsledky.

RCPSSolver využívá existující SAT solvery a to Glucose a MiniSAT.
Vstupem pro RCPSSolver jsou instance RCPS problému z~PSPLIB, což je knihovna obsahující sadu benchmarků
pro RCPS problém.

Sekce \ref{sec:analysis} obsahuje analýzu problému, formální definici RCPS a SAT problémů.
V~sekci \ref{sec:concept} je popsána samotná redukce na SAT problém a v~sekci \ref{sec:arch}
architektura implementovaného nástroje.
Sekce \ref{sec:exps} shrnuje provedené experimenty s~vytvořeným nástrojem.

\section{Analýza \rcps}
\label{sec:analysis}
V~této sekci bude napřed formálně definován \rcps\ problém a optimalizační problém související s~jeho řešení.
Dále bude popsána knihovna PSPLIB a její formát popisu instancí RCPS problému.
Následně budou zkoumány možnosti a způsoby využití SAT solving při řešení RCPS problému.

\subsection{Formální definice RCPS}
\rcps je definován šesticí $(V, p, E, R, B, b)$ \cite{artigues:2007}, kde
\begin{enumerate}
    \item $V=\{A_0, \ldots, A_{n+1}\}$ je množina aktivit, které mají být vykonány.
    Dle konvence je $A_0$ aktivita reprezentující začátek rozvrhu a $A_{n+1}$ aktivita reprezentující konec rozvrhu.
    \item $p: V~\rightarrow \mathbb{N}$ je funkce udávající dobu trvání aktivit.
    \item $E \subseteq V\times V$ je precedenční relace.
    Pokud $(A_i, A_j) \in E$, tak aktivita $A_i$ musí být provedena před aktivitou $A_j$.
    \item $R=\{R_1,\ldots,R_q\}$ je množina zdrojů.
    \item $B: R \rightarrow \mathbb{N}$ je funkce udávající kapacitu zdrojů.
    \item $b: V~\times R \rightarrow \mathbb{N}$ je funkce udavájící množství určitého zdroje, které vyžaduje daná aktivita pro
    svoje provádění.
\end{enumerate}

Řešením tohoto problému je vektor $<S_0,\ldots,S_{n+1}>$, kde $S_i$ je doba začátku aktivity $A_i$.
Toto řešení můžeme nazývat rozvrhem.
Řešení musí splňovat omezení daná precedenční relací a dostupností zdrojů, což lze formálně zapsat následovně:
\begin{equation}
 \forall (A_i,A_j) \in E: S_j - S_i \geq p(A_i)
\end{equation}
\begin{equation}
 \forall R_k \in R\ \forall t \geq 0: \sum_{A_i \in A_t} b(A_i, R_k) \leq B(k)
\end{equation}
kde $A_t=\{A_i \in A\,|\, S_i \leq t \leq S_i+p(A_i)\}$.

Kritériem optimálnosti u~\rcps je tzv. \emph{makespan}, což je doba začátku provádění aktivity $A_{n+1}$.
Optimalizačním problémem tedy je nalézení řešení \rcps\ úlohy s~minimální makespan.

V~dalším textu jsou uvažovány \emph{single-mode} \rcps\ úlohy.
Single-mode znamená, že aktivity dané úlohy mají pouze jeden mód činnosti,
narozdíl od tzv. \emph{multi-mode} úloh jejichž aktivity mají více módu činnosti
a každý mód má odlišné požadavky na spotřebu zdrojů.

Pro instanci RCPS problému také uvažujeme u~jejích aktivit časy nejdřívějšího a nejpozdějšího možného začátku (a
také konce) činnosti dané aktivity.
Dále se pro instanci zjišťuje doba tvrání \emph{kritické} cesty váženým grafem vytvořeným tak, že uzly odpovídají jednotlivým
aktivitám a hrany jsou ohodnoceny dobou jejich trvání a jsou mezi uzly, jejichž aktivity jsou navzájem v~precedenční
relaci.
Kritická cesta je nejdelší cesta mezi uzly představujícími aktivitu $0$ a aktivitu $n+1$ a je vypočítána
pomocí Floyd-warshallova algoritmu.
Z~tohoto výpočtu dostáváme také údaje o~nejdelších cestách mezi jednotlivými uzly, což lze následně použít
při výpočtu doby nejdřívějšího a nejpozdějšího začátku.
Kritická cesta pak představuje dobu, za kterou by šla úloha splnit nejdříve, pokud by neexistovalo omezení dané
množství zdrojů, ale pouze omezení dané precendenční relací.
Kritická cesta bude v~následujícím textu uvažována jako spodní hranice řešení, tedy hranice u~níž víme, že nelze
dosáhnout nižšího makespan, než je její hodnota.
Opakem je poté horní hranice řešení, která udává maximální dobu, kterou může makespan nabývat a jejíž volba
byla během implementace různá, více v~sekci \ref{sec:arch}.

\subsection{PSPLIB}
PSPLIB je knihovna združíjící sady instancí \rcps\ problému v~jeho různých variantách a jejich optimální a heuristická řešení \cite{psplib}.
Knihovna používá ke generování instancí problému vlastní nástroj \emph{ProGen}.
Ve shodě se zadáním projektu byly použita data knihovny PSPLIB jako vstupy dokumentováného nástroje.
Použití knihovny je vhodné také díky možnosti porovnávat výstupy vytvořeného programu s~optimálními řešeními, které
knihovna pro mnoho instancí problému obsahuje.
Příklad vstupních dat lze najít v~adresáří \emph{input}.

\subsection{SAT Solvinig}
Metody a nástroje SAT solvingu se zabývají řešením SAT problému (který je NP-úplný),
který odpovídá na otázku, zdali je daná formule výrokové logiky splnitelná.
V~našem případě uvažujeme formuli výrokové logiky v~\emph{konjunktnivní} normální formě (CNF).
formule je definovaná přes množinu proměnných, které nabývají hodnoty z~množiny $\{true, false\}$
a je složena z~následujících prvků:
 \begin{itemize}
 	\item \emph{Literálu}, což jsou samotné proměnné nebo jejich negace
 	\item \emph{Klausulí}, což jsou disjunkce ($\vee$) literálů
	\item Samotná výroková formule v~CNF je pak konjunkcí ($\wedge$) klausulí.
 \end{itemize}.

Ohodnocení formule je konkrétní zobrazení jejich proměnných na hodnoty $\{true, false\}$.
Formule je \emph{splnitélná}, pokud existuje ohodnocení, při kterém je celá formule vyhodnocena
jako $true$.
Takové ohodnocení se potom nazývá modelem formule v~CNF.

Programy řešící SAT problém se nazývají \emph{SAT Solvery}.
V~poslední době proběhl v~oblastni SAT solverů výrazný pokrok a mnohé z~nich jsou již
schopny  řešit SAT problémy obsahující velké formule.
Porovnání možností a výkonu SAT solverů lze najít na \cite{www:sat}.

Základním algoritmem použivaným v~SAT Solvingu (a dnešních SAT Solverech) je
\emph{Davis–Putnam\-Logemann–Loveland (DPLL) algoritmus} \cite{dpll:1960, dpll:1962}.
Algoritmus lze najít v~\ref{alg:dpll} a bude následovat jeho krátký popis.

Funkce \emph{propagate} ohodnotí proměnné na základé aktuálního částečného ohodnocení tak, že
provedená nová ohodnocení jsou důsledkem aktuálního stavu.
Pokud při tomtu ohodnocení nevznikne konflikt, t.j. jedna klausule při učitém ohodnocení některé z~proměnných nabyde hodnoty $true$,
zatímco jiná (konfliktní) klausule se při takovémto ohodnocení stane $false$, tak pokud jsou již ohodnoceny všechny proměnné, je vrácena
hodnota $true$.
Pokud konflikt nenastane, ale nejsou ohodnoceny všechny proměnné tak, je zvýšena úroveň zanoření při rozhodování (proměnná decision\_level)
a je zavolána funkce \emph{decide}, která rozhodne, která další proměnná bude ohodnocena a na které se tedy bude další výpočet větvit.

Pokud funkce propagate vrátí konfliktní klausuli, tak je zavolána funkce \emph{analyze}, která určí ke které úrovni zanoření při ohodnocování
proměnných se bude navracet.
Všechna ohodnocení provedena hloubějí než v~této úrovni jsou pak zrušena.
V~moderních SAT Solverech funkce analyze také dokáže vytvořit \emph{naučenou} klausuli, která je důsledkem aktuální databáse klausulí a která
má popisovat příčinu posledního konfliktu konfliktu.

\begin{algorithm}
\label{alg:dpll}
    \KwIn{CNF formule}
    \KwOut{$true$ pokud je formule splnitelná, jinak $false$}
    decision\_level = 0\;
    \While{$true$}
    {
        propagate()\;
        \eIf{Není konflikt}
        {
            \eIf{Všechny proměnné přiřazeny}
            {
                \Return $true$\;
            }
            {
                ++decesion\_level\;
                decide()\;
            }
        }
        {
            analyze()\;
            \eIf{nalezen konflikt na nejvyšší úrovni}
            {
                \Return $false$\;
            }
            {
                backtrack()\;
            }
        }
    }
\caption{DPLL Algoritmus}
\end{algorithm}

V~této práci byly použity SAT Solvery \emph{MiniSAT} \cite{www:minisat} a \emph{Glucose} \cite{www:glucose}, která
používají další optimalizace k~zlepšení efektivity výpočtu.
MiniSAT byl vybrán na základě článku \cite{horbach:10}, kde byl úspěšně použit právě pro řešení RCPS problému.
Glucose je solver založený na MiniSATu, ale implementující některé další optimalizace, a proto s~ní budou provedeny
experimenty, které si kladou za cíl zjistit, zdali přináší zlepšení pro výkonu při řešení RCPS problému.
% how is it used in my model
% used sat solvers

\section{Konceptuální model}
\label{sec:concept}
RCPS problém lze řešit jeho redukcí na SAT problém a následním řešením pomocí SAT solveru.
V~této kapitole bude právě tato redukce popsána a to dle přístupu z~\cite{horbach:10}.

SAT formule budou definovány nad následujícími proměnnými:
\begin{itemize}
    \item Startovací proměnné $s_{it}$, kde $i\in V$ a $t\in{es_i,\ldots,ls_i}$, pro které platí: \newline 
    $s_{it}=
        \left\{
        \begin{array}{ll}
             true & \mbox{pokud} \emph{ aktivita }j \emph{ začíná v~čase }t \\
             false & \mbox{jinak}\\
        \end{array}
        \right.
        $
    \item Procesní proměnné $u_{it}$, kde $i \in V$ a $t \in {es_i,\ldots, lf_i}$, pro které platí: \newline
    $u_{it}=
        \left\{
        \begin{array}{ll}
             true & \mbox{pokud} \emph{ aktivita }j \emph{ je ve zpracování  v~čase }t \\
             false & \mbox{jinak}\\
        \end{array}
        \right.
        $
\end{itemize}

Nyní přistupme k~samotné redukci RCPS problému do CNF formulí.
Správná kombinace startovacích a procesních proměnných je zaručena pomocí tzv. \emph{klausulí konzistence}:
\begin{equation}
\label{eq:1}
   \neg s_{it} \vee u_{il},\emph{ kde } i\in\{es_i,\ldots,ls_i\}, l\in\{t,\ldots,t+d_i-1\}  
\end{equation}

Dodržení omezení daných precedenční relací zajišťují tzv. \emph{precedenční klausule}:
\begin{equation}
\label{eq:2}
   \neg s_{it} \bigvee_{l\in\{es_j,\ldots,t-d_j\}} s_{jl},\emph{ kde } (j,i) \in E, t \in\{es_i,\ldots,ls_i\}   
\end{equation}
Oproti přísputu z~\cite{horbach:10} je zde použito $l\in\{es_j,\ldots,t-d_j\}$ namísto $l\in\{es_j,\ldots,es_i-d_j\}$ tak,
aby klausule skutečně vyjadřovala, že začne-li aktivita $i$ v~čase $t$, tak aktivita, která ji má dle precedenční
relace předcházet, začala dříve alespoň o~svého trvání.

Dalším typem klasulí jsou \emph{klausule startovací}, které zaručují, že každá aktivita někdy začne:
\begin{equation}
\label{eq:3}
   \bigvee_{t\in\{es_i,\ldots,ls_{i}\}} s_{it},\emph{ kde } i \in
V~\end{equation}

Dosud uvedené klausule nezaručují, že nebude v~jeden okamžik naplánováno více aktivit, které ovšem můžou mít rozdílné
větší nároky na některý zdroj než je jeho dostupné množství.
Takovotou množinu aktivit $C$, pro kterou u~některého zdroje $k$ platí $\sum_{i\in C} r_{ik} > R_k$, nazveme \emph{pokrytím}.
Minimální pokrytí je takové, že bez některé aktivity $i\in C$, přestává být množina $C$ prokrytím.
Nepřečerpání některého ze zdrojů lze zajistit porstřednictvím \emph{klausulí pokrytí}:
\begin{equation}
\label{eq:4}
   \bigvee_{i\in C} \neg u_{it},\emph{ kde } t\in{0,\ldots,T-1}, C \emph{ je minimální pokrytí}   
\end{equation}

Každá množina klausulí z~\ref{eq:1},\ref{eq:2},\ref{eq:3} nabývá polynomiální velikosti a je tedy řešitelná pomocí moderních SAT solverů,
a proto je možné je vygenerovat na základě instance RCPS problému před spuštěním SAT solveru.
Počet klausulí \ref{eq:4} ovšem roste exponencíálně, a tudíž by jejich kompletní vygenerování bylo možné jen pro instance
s~malým počtem aktivit,
Proto jsou tyto klasule v~dokumentované implementaci přídávány do databáse SAT solveru dynamicky.
Bližší informace stran implementace samotné jsou v~sekci \ref{sec:arch}.

Aby bylo možné provádět samotnou optimalizaci, je třeba přidat klausule omezující maximální makespan.
Nazvěme tyto klausule \emph{časovými}:
\begin{equation}
\label{eq:5}
   \bigvee_{i\in C} \neg s_{n+1,t},\emph{ kde } t\in{l+1,\ldots,ls_{n+1}}, \emph{ l je maximální makespan}   
\end{equation}

Stejně jako v~\cite{horbach:10} byly přidány následující klausule, které přináší zrychlení výpočtu SAT solveru:
\begin{equation}
\label{eq:6}
   \neg u_{it} \vee u_{i,t+1} \vee u_{i,t-d_i+1},\emph{ kde } i\in V, s\in\{ef_i,\ldots,lf_i-1\}  
\end{equation}
Klausule udávají, že doba $t$ je doba konce aktivity $i$ a SAT solver může odvodit, že aktivita $i$ začíná v~době
$t-d_i+1$.

Tím je redukce RCPS problému na SAT problém kompletní včetně zakódování optimalizačního problému a přídání
klausulí zrychlujících výpočet SAT Solveru.

\section{Architektura}
\label{sec:arch}
V~této sekci bude popsána architektura implementovaného programu, implementační optimalizace a budou zmíněny použité SAT Solvery.

Logický návrh architektury programu je na obrázku \ref{fig:arch}.
Program nejprve načte vstup, kterým je soubor z~knihovny PSPLIB, poté ho
převede do interní reprezentace (na Obrázku jako \emph{Instance RCPS problému}).
V~této interní reprezentaci se instance RCPS problému předá optimilazátoru,
který pomocí příslušných modulů vypočte kritckou cestu a s~ní související informace a doplní je do reprezentace RCPS problému.
Následně je vytvořena interní reprezentace SAT problému (SAT formule v~CNF), která je následně
převedena do reprezentace příslušného SAT Solveru, který je v~nazávěr spuštěn.
Toto optimalizátor postupně provádí pro jednotlivé makespan, dokuď není nalezen ten nejnížší možný.
\begin{figure}
\begin{center}
    \input{arch.tikz}
    \caption{Koncptuální návrh programu}
    \label{fig:arch}
\end{center}
\end{figure}

Následuje seznam tříd implementující jednotlivé bloky z~logického návrhu programu:
\begin{itemize}
 \item Parser
    \begin{itemize}
        \item Třída \emph{RCPSParser} obsahuje metody pro načtení souboru se vstupem z~PSPLIB a převede ho do interní
        reprezentace RCPS problému (třída \emph{RCPSInstance}).
    \end{itemize}
 \item Instance RCPS problému
    \begin{itemize}
        \item Třída \emph{RCPSInstance} v~sobě uchováva informace uvedené v~definici RCPS problému v~sekci \ref{sec:analysis}.
        Uchovává také informace o~nejdřívějších a nejpozdějších možných časech začátků a konců jednotlivých aktivit.
    \end{itemize}
 \item Výpočet kritické cesty
    \begin{itemize}
        \item Třída \emph{RCPSGraph} reprezentuje graf, do které ho je převeden RCPS problém, aby mohla být spočítáná kritická cesta a s~ní
        související informace jako možné časy začátků a konců aktivit.
        Obsahuje také metody pro výpočet této kritické cesty pomocí Floyd-Warshallova algoritmu.
    \end{itemize}
 \item Interní SAT model
    \begin{itemize}
        \item Třída \emph{RCPSSATModel} reprezentuje interně SAT problém, na který byl redukován RCPS problém.
        Obsahuje také metody pro tuto redukci.
    \end{itemize}
 \item Převod do reprezentace SAT solveru
    \begin{itemize}
        \item Třída \emph{RCPSModel2Glucose} obsahuje metody převádějící interní SAT model v~třídě \emph{RCPSSATModel}
        do interní reprezentace SAT solveru \emph{Glucose}.
        \item Třída \emph{RCPSModel2Minisat} obsahuje metody převádějící interní SAT model v~třídě \emph{RCPSSATModel}
        do interní reprezentace SAT solveru \emph{MiniSAT}.
    \end{itemize}
 \item Byly použity následující dva SAT solvery:
    \begin{itemize}
        \item \emph{MiniSAT} \cite{www:minisat} je SAT solver použíty v~\cite{horbach:10}.
        Dříve patřil mezi nejlepší SAT solvery (oceněný v~soutěži \cite{www:sat}), dnes již neimplemetuje
        všechny aktuální heuristiky a optimalizace používaný v~SAT Solvingu.
        \item \emph{Glucose} \cite{www:glucose} je nádstavnou nad MiniSAT, která implementuje
        pokročilejší optimalizace a je v~posledních letech oceňována v~soutěži SAT Competition \cite{www:sat}.
        Zachovává rozhraní MiniSAT, tudíž ji bylo možné použít bez nutnosti výraznějších změn postupů použitých při
        modifikaci MiniSAT.
    \end{itemize}
 \item Optimalizátor
    \begin{itemize}
        \item Třída \emph{RCPSOptimizer} realizuje vlastní výpočet a optimalizaci pomocí ostatních modulů.
    \end{itemize}
\end{itemize}

\subsection{Modifikace SAT solveru}
Jak bylo řečeno v~sekci \ref{sec:concept}, množství klausulí pokrytí \ref{eq:4} dosahuje exponenciální složitosti,
proto není možné tyto klausule vygenerovat před spuštěním samotného SAT solveru.
Je nutné je generovat dle potřeby během výpočtu, což lze udělat tak \cite{horbach:10}, že je spuštěn SAT solver bez
těchto klausulí a na základě vypočteného ohodnocení proměnných je ověřováno, že v~žádném čase
nedošlo k~přečerpání žádného zdroje.
Pokud by k~tomuto došlo, je přidána příslušná klausule pokrytí, která tomuto zabrání a SAT solver je spuštěn
znovu.
Nevýhoda tohoto přístupu je taková, že SAT solver vždy ztrácí celý kontext výpočtu a musí začínat od začátku, a proto
je tento přístup vhodný jen u~malých problému, a tedy nebyl v~této práci implementován.

Implementován byl přístup, který modifikuje fukci \emph{propagate} v~SAT solveru.
Vždy když je pravdivě ohodnocen nějaký literál obsahující procesní proměnnou $u_{it}$, tak je zkontrolováno,
zdali tímto ohodnocením není v~čase $t$ překročeno množství některého ze zdrojů použitých aktivitou $i$.
Pokud ano, je vygenerována příslušná klausle pokrytí, která je přidána do databáse klausulí a vrácena jako konflitkní klausule.
Pokud k~takovému porušení nedocházi, jsou vygenerovány klausule pokrytí zabraňující tomu, aby byla 
(dosud neohodnocená) procesní proměnná $u_{jt}$ ohodnocena jako $true$,
pokud by činnost aktivity $j$ v~čase $t$ vedla k~přečerpání některého ze zdrojů.

Přidání nové klausule za běhu nebylo možné provést přes funkci \emph{addClause} z~rozhraní SAT solverů, ale použitím
interní funkce \emph{attachClause} a přidáním nové klausule na zásobník klauslí v~proměnné \emph{clauses}.

Další provednou optimalizací je upřednostnění výběru procesních proměnných ve funkci \emph{decide} před výběrem
startovacích proměnných.
Tato optimalizace je také navržena v~\cite{horbach:10} a empirickými experimenty s~programem RCPSSolver
byl ověřeno, že skutečně zrychluje výpočet.

\subsection{Hledání optimálního řešení}
Původně bylo hledání optimálního řešení implementováno tak, že se před
zahájením samotné optimalizace vypočetla kritická cesta a s~ní související informace.
Poté byl zvolen makespan dle horního odhadu uvedeného v~popisu instance z~PSPLIB
a ten byl postupně snižován dokud nebylo dosaženo spodní hranice, která
byla dána kritickou cestou.
Poslední makespan, u~kterého bylo možné najít řešení RCPS problému byl pak prohlášen
za optimální řešení.
Tento přístup se ovšem ukázal jako velmi neefektivní, a proto byl
implementován jiný, kde se prohledává od spodní hranice dané kritickou cestou,
makespan se zvyšuje o~jedna a jako horní hranice je brána hodnota o~jedna
vyšší než aktuální makespan.
Pro tuto horní hranici jsou spočteny nejdřívější a nejpozdější možné začátky
jednotlivých aktivit a teprve poté je RCPS problém zakódován do SAT problému.
Tento postup se ukázal jako efektivnější nejen v~hledání optimálního řešení, ale i
v~rozhodování jedné instance SAT problému, protože obsahují méně proměnných. 

\subsection{Implementační problémy}
\label{sub:impl}
SAT solvery při řešení větších instancí končily chybou \texttt{segmentation fault}.
Příčinu této chyby se nepodařilo zjistit a není zřejmé, zdali se jedná
o~chybu zanešenou implementací dynamického přidávání klausulí a nebo o~chybu
způsobenou velikostí řešeného problému.
Proto v~případech, kdy by mělo k~chybě \texttt{segmentation fault} dojít,
je daná instance prohlášena za nesplnitelnou a je zvětšen makespan.
Touto cestou nelze najít opravdu optimální řešení, protože přávě kolem
hodnoty optimálního makespan dochází k~nárustu složitosti výpočtu a tedy
i zmíněné chybě, ale lze dostat alespoň suboptimální řešení udavající
nejnižší makespan, pro který jde úloha vyřešit.
V~případě, že je použita tato heuristika, je vypsáno na standardní výstup
\emph{NOT OPTIMAL}, aby bylo zřejmé, že výsledek nemusí být přesný.

\section{Experimenty}
S~implementovaným nástrojem byly provedeny experimenty nad vstupy
z~knihovny PSPLIB, konkrétně byly použity sady \emph{j30, j60, j120}, kde
číslice za písmenem 'j' udává počet aktivity, které obsahují instance v~dané sadě.
Měření byla provedena na počítači s~procesorem Intel Core 2 Duo (2.13 GHz) a 4 GiB paměti.
Časový limit pro optimalizaci jedné úlohy byl stanoven na $30$ minut.
Experimenty byly provedeny za použití SAT solveru MiniSAT a byl měřen čas
procesu na CPU.

V~tabulce \ref{table:jreses} jsou uvedeny výsledky experimentů.
V~tabulce je uvedeno procento úspěšně optimalizovaných úloh z~dané sady.
Dále také obsahuje kolik procent úloh z~dané sady bylo vyřešeno pod daný časový limit.
V~porovnání s~výsledky, k~nimž dospěl autor v~\cite{horbach:10}, není implementovaný
RCPSSolver tak efektivní a úspěšný.
To lze přisuzovat možným nedostatkům v~modifikaci SAT solveru, jejíž přesná podoba nebyla
v~\cite{horbach:10} přesně popsána.

\begin{table}[tb]
\begin{center}
  \begin{tabular}{ | l | r | r | r | r | r | r |}
   \hline
    & \textbf{Optimalizována [\%]} & Pod 1s [\%] & Pod 2s [\%] & Pod 5s [\%] & Pod 10s [\%] Pod 50s [\%]\\ \hline \hline
    j30 &$44454.7$ & $46500.9$ & & & \\ \hline
    j60 & $47893.3$ & $48186.44$ & & & \\ \hline
    j120 & $42 029$ & $42 029$ & & & \\ \hline
   \end{tabular}
   \caption{Tabulka výsledků s~experimenty se sadami j30, j60, j120 z~PSPLIB.}
   \label{table:jreses}
\end{center}
\end{table}

Dalším výstupem experimentů jsou grafy \ref{pic:j30}, \ref{pic:j60}, \ref{pic:j120},
které ukazují dobu, kterou SAT solver potřeboval na rozhodnutí instance SAT problému
s~daným makespanem, v~závislosti na vzdálenosti tohoto makespan od optimálního.
V~grafu jsou zaneseny jen výsledky, u~nichž byla doba řešení úlohy delší nebo rovna 1 sekunda.
Nicméně, takovýchto případů bylo pouze TODO
Z~grafu je patrné, že náročnost na řešení instancí SAT problému vztoupala blíže optimálnímu řešení instance RCPS problému.
Několik případů v~každé sadě bylo velmi náročných, což odpovídá výraznému navýšenní doby výpočtu v~blízkosti optima.

\begin{figure}[tb]
    \includegraphics[scale=0.5]{dst_j30}
    \caption{Doba řešení instance SAT problému v~závislosti na vzdálenosti makespan od optima v~instanci RCPS problému redukovaného na SAT.}
    \label{pic:j30}
\end{figure}

Provedené experimenty ukazují, že pomocí SAT solvingu se daří optimalizovat většinu instancí z~PSPLIB.
Nicméně v~každé sadě se nachází několik těžkých případů, které se nepodařilo RCPSSolveru vyřešit.
U~těchto těžkých případů také docházelo také k~nárustu doby výpočtu SAT solveru, který jinak dokázal
řešit zadané problémy velmi rychle.

\section{Závěr}
% make this beatiful!

\newpage
\appendix
\section{Instalace}
\label{app:install}
K~projektu je přiložen soubor \emph{Makefile}, tudíž lze zdrojové kódy zkompilovat pomocí příkazu \texttt{make}.
Pro úspěšnou kompilaci je nutné mít nainstalovaný překladač GCC verze 4.8.
Před spuštění je třeba dokončit konfiguraci prostředí skriptem \texttt{configure.sh},
který přidá do systemových proměnných cestu ke knihovnám MiniSAT.
Výstupem kompilace je spustitelný binární soubor \texttt{rcps\_solver} v~adresáři \texttt{bin}.
\section{Uživatelský manuál}
\label{app:help}
RCPSSolver lze spouštět z~příkazového řádku následujícím způsobem:
\\
\\
  rcps\_solver soubor [solver] [timeout]
  \begin{itemize}
    \item \texttt{soubor} $\ldots$ Cesta k~vstupnímu souboru s~instancí problému z~PSPLIB
    \item \texttt{solver} $\ldots$ Volba SAT solveru.  
    \begin{itemize}
        \item m $\ldots$ MiniSAT (default).
        \item g $\ldots$ Glucose.
    \end{itemize}
    \item \texttt{timeout} $\ldots$ Doba pro řešení optimalizačního problému.
    Neovlivní činnost SAT solveru, takže bude vždy před ukončením programu dořešena poslední SAT úloha.
    \item Pokud jsou oba použity nepovinné parametry \texttt{solver} i \texttt{timeout}, je nutné dodržet jejich pořadí.
  \end{itemize}

\section{Výstup}
\label{app:output}
RCPSSolver průběžně informuje o~svojí činnosti na standardní chybový výstup.
Na standardní výstup pak vypisuje následující informace:
\begin{itemize}
    \item \texttt{Makespan: $X$ [$Y$] $U$ $V$} $\ldots$ $X$ je aktuální makespan, $Y$ udává, zdali je úloha řešitelná v~daném makespan,
    $U$ je doba řešení SAT problému a $V$ celková doba řešení RCPS problému pro daný makespan, oba údaje jsou v~sekundách.
    \item \texttt{Done X} $\ldots$ X je celková doba výpočtu optimalizace RCPS problému v~sekundách.
    \item \texttt{Optimal: X} $\ldots$ X je optimální řešení RCPS problému nalezené RCPSolverem.
    \item \texttt{NOT OPTIMAL} $\ldots$ byla použita heuristika ze sekce \ref{sub:impl} a výsledek nemusí být optimální.
\end{itemize}
Další výstupy pak mohou být informace, které vypisuje SAT solver.

\newpage
\bibliography{literatura}
\bibliographystyle{czechiso}
\end{document}
